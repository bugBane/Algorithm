动态规划:核心思想是将大问题划分为小问题进行解决,从而一步一步获取最优解的处理算法.
    动态算法与分治算法与分治算法类似,其基本思想也是将待求解问题分解为若干个子问题,先求解子问题,然后从这些子问题得到原问题的解.
    与分治算法不同的是,适用于动态规划求解的问题,经分解得到的子问题往往不是相互独立的.(下一个子阶段的求解建立在上一个子阶段解的基础上进行进一步求解)
    动态规划可以通过填表的方式,得到最优解

实战:背包问题
分析:背包问题主要是指一个给定容量的包,若干具有一定价值和重量的物品,如何选择放入背包使物品的价值最大.
其中又分为:01背包和完全背包(完全背包:每件物品都都有无限件可用)
这里的问题属于01背包问题,即每个物品最多放一个,而无限背包问题可以转化为01背包.
    public static int dynamic(int capacity, int[] weight, int[] price) {
        // 将复杂问题拆解成小问题，归纳小问题一步步推导至大问题，拆分的问题每往前一步，可能需要使用之前问题动态结果
        // (和分治算法不一样，分治算法也是分，但是分开是独立的:汉诺塔2和64是一样的处理都是死板的，不会因为64而造成处理2步骤发生变化)
        //  物品重量\背包容量   0     1     2     3     4
        //  0                0     0     0     0     0
        //  吉他(1)           0     1500  1500  1500  1500
        //  电子琴(4)         0     1500  1500  1500  3000
        //  唢呐(3)           0     1500  1500  2000  2000+1500
        // 记录结果集：背包容量和物品重量的二维数组，结果为所盛放物品价格
        int[][] value = new int[weight.length + 1][capacity + 1];// +1的原因是空出第一行和第一列用来记录00情况
        // 用来打印当前结果怎么放的(路径)
        int[][] path = new int[weight.length + 1][capacity + 1];
        // 默认为0其实可以不用下面代码
        // 第一行
        for (int i = 0; i < value[0].length; i++) {
            value[0][i] = 0;
        }
        // 第一列
        for (int i = 0; i < value.length; i++) {
            value[i][0] = 0;
        }
        // 经过上价格结果集分析，最大价值=背包对应容量时的结果
        // 结果集是按照先放入本次物品，如果背包无法容纳就取上次结果为本次结果，否则就判断(放入本物品价值+剩余容量物品价值)和上一次物品谁大，
        // 谁大就采取这种放置方式，并记录到该背包容量时的结果
        // 1.将每次结果放入结果集
        for (int i = 1; i < value.length; i++) {
            for (int j = 1; j < value[i].length; j++) {
                // 如果 背包容量 < 物品重量
                if (j < weight[i - 1]) {
                    // 取上次物品结果为本容量结果
                    value[i][j] = value[i - 1][j];
                } else {
                    // 判断(放入本物品价值+剩余容量物品价值)和上一次物品谁大
                    int p = price[i - 1] + value[i - 1][j - weight[i - 1]];//放入本物品价值+剩余容量物品价值(注意剩余容量不能再包含当前物品，因为已经放入了)
                    if (p > value[i - 1][j]) {
                        value[i][j] = p;
                        path[i][j] = 1;
                    } else {
                        // 取i-1结果为本容量结果
                        value[i][j] = value[i - 1][j];
                    }
                }
            }
        }
        int i = path.length - 1;
        int j = path[0].length - 1;
        while (i > 0 && j > 0) {
            if (path[i][j] == 1) {
                System.out.println("第" + i + "放入背包");
                // 注意排除掉多余的数据，需要的为：第一次放入的数据
                j -= weight[i - 1];
            }
            i--;
        }
        return value[weight.length][capacity];
    }